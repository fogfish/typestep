//
// Copyright (C) 2025 Dmitry Kolesnikov
//
// This file may be modified and distributed under the terms
// of the MIT license.  See the LICENSE file for details.
// https://github.com/fogfish/typestep
//

package typestep

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"runtime"
	"strings"
	"time"

	"github.com/aws/aws-cdk-go/awscdk/v2/awslambda"
	"github.com/aws/constructs-go/constructs/v10"
	"github.com/fogfish/scud"
)

// Signature for type-safe entry point to lambda function
type Lambda[A, B any] = func(context.Context, A) (B, error)

// Deploys a function as an AWS Lambda while preserving type-safe annotations.
// This construct is designed for Infrastructure as Code (IaC) scenarios where
// type safety is critical, such as when integrating with AWS Step Functions.
//
// Unlike a typical AWS Lambda deployment where `func main()` serves as the
// entry point, this construct requires a function that returns a valid
// AWS Lambda handler of the form:
//
//	func M() func(context.Context, A) (B, error) {
//		/* AWS Lambda bootstrap code goes here */
//		return func(context.Context, A) (B, error) {
//			/* AWS Lambda handler goes here */
//		}
//	}
//
// The primary reason is that this construct automatically generates a `main.go`
// file from the provided handler, ensuring consistent wiring and preserving type
// information throughout the deployment process.
type Function[A, B any] struct{ awslambda.IFunction }

// Import existing function
func Function_FromFunctionArn[A, B any](scope constructs.Construct, id *string, arn *string) *Function[A, B] {
	return &Function[A, B]{
		IFunction: awslambda.Function_FromFunctionArn(scope, id, arn),
	}
}

// Specify the deployment properties for "type-safe" AWS Lambda.
//
// Unlike a typical AWS Lambda deployment where `func main()` serves as the
// entry point, this construct requires a function that returns a valid
// AWS Lambda handler of the form:
//
//	func M() func(context.Context, A) (B, error) {
//		/* AWS Lambda bootstrap code goes here */
//		return func(context.Context, A) (B, error) {
//			/* AWS Lambda handler goes here */
//		}
//	}
//
// The primary reason is that this construct automatically generates a `main` function
// file from the provided handler, ensuring consistent wiring and preserving type
// information throughout the deployment process.
//
// Use FunctionTyped as a constructor for FunctionTypedProps to eliminate the
// boilerplate
type FunctionTypedProps[A, B any] struct {
	*scud.FunctionGoProps
	Handler func() Lambda[A, B]
}

// Constructor for FunctionTypedProps to support automatic inference of types from function
func FunctionTyped[A, B any](f func() Lambda[A, B], props *scud.FunctionGoProps) *FunctionTypedProps[A, B] {
	return &FunctionTypedProps[A, B]{
		FunctionGoProps: props,
		Handler:         f,
	}
}

// Instantiates deployment for "type-safe" AWS Lambda.
func NewFunctionTyped[A, B any](scope constructs.Construct, id *string, spec *FunctionTypedProps[A, B]) *Function[A, B] {
	autogen(spec.Handler, spec.SourceCodeModule, spec.SourceCodeLambda)
	spec.SourceCodeLambda = filepath.Join(spec.SourceCodeLambda, agdir)
	flambda := scud.NewFunctionGo(scope, id, spec.FunctionGoProps)

	return &Function[A, B]{
		IFunction: flambda,
	}
}

//------------------------------------------------------------------------------

const agdir = "autogen"

func autogen[A, B any](f func() Lambda[A, B], scModule, scLambda string) string {
	fptr := reflect.ValueOf(f).Pointer()
	fobj := runtime.FuncForPC(fptr)
	if fobj == nil {
		panic(fmt.Errorf("failed to discover function metadata"))
	}

	name := fobj.Name()
	path := strings.TrimSuffix(name, filepath.Ext(name))
	base := filepath.Base(name)

	code := fmt.Sprintf(`// DO NOT EDIT !!!
// THE FILE IS AUTO GENERATED BY github.com/fogfish/typestep
// %s
package main

import (
  "github.com/aws/aws-lambda-go/lambda"
	"%s"
)

func main() { lambda.Start(%s()) }
`, time.Now(), path, base)

	ffile, _ := fobj.FileLine(fptr)
	goroot := strings.Split(ffile, "go/src")
	codepath := filepath.Join(goroot[0], "go/src", scModule, scLambda, agdir, "main.go")

	err := os.MkdirAll(filepath.Dir(codepath), 0766)
	if err != nil {
		panic(err)
	}
	err = os.WriteFile(codepath, []byte(code), 0766)
	if err != nil {
		panic(err)
	}

	return path
}
