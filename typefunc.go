//
// Copyright (C) 2025 Dmitry Kolesnikov
//
// This file may be modified and distributed under the terms
// of the MIT license.  See the LICENSE file for details.
// https://github.com/fogfish/typestep
//

package typestep

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"runtime"
	"strings"
	"time"

	"github.com/aws/aws-cdk-go/awscdk/v2/awslambda"
	"github.com/aws/constructs-go/constructs/v10"
	"github.com/fogfish/scud"
)

// Signature for type-safe entry point to lambda function
type Lambda[A, B any] = func() func(context.Context, A) (B, error)

// Deploys a function as an AWS Lambda while preserving type-safe annotations.
// This construct is designed for Infrastructure as Code (IaC) scenarios where
// type safety is critical, such as when integrating with AWS Step Functions.
//
// Unlike a typical AWS Lambda deployment where `func main()` serves as the
// entry point, this construct requires a function that returns a valid
// AWS Lambda handler of the form:
//
//	func M() func(context.Context, A) (B, error) {
//		/* AWS Lambda bootstrap code goes here */
//		return func(context.Context, A) (B, error) {
//			/* AWS Lambda handler goes here */
//		}
//	}
//
// The primary reason is that this construct automatically generates a `main.go`
// file from the provided handler, ensuring consistent wiring and preserving type
// information throughout the deployment process.
type Function[A, B any] struct {
	Function awslambda.Function
}

func (f *Function[A, B]) HKT1(func(A) B)         {}
func (f *Function[A, B]) F() awslambda.IFunction { return f.Function }

// Instantiates deployment for "type-safe" AWS Lambda.
func NewFunctionTyped[A, B any](scope constructs.Construct, id *string, spec *FunctionTypedProps[A, B]) *Function[A, B] {
	path := autogen(spec.Handler, spec.SourceCodeModule, spec.AutoGen)
	spec.SourceCodeLambda = filepath.Join(path, agdir)
	flambda := scud.NewFunctionGo(scope, id, spec.FunctionGoProps)

	return &Function[A, B]{Function: flambda}
}

// Imports an existing AWS Lambda function with type-safe annotations.
type IFunction[A, B any] struct {
	Handler awslambda.IFunction
}

func (f *IFunction[A, B]) HKT1(func(A) B)         {}
func (f *IFunction[A, B]) F() awslambda.IFunction { return f.Handler }

// Import existing function
func Function_FromFunctionArn[A, B any](scope constructs.Construct, id *string, arn *string) *IFunction[A, B] {
	return &IFunction[A, B]{
		Handler: awslambda.Function_FromFunctionArn(scope, id, arn),
	}
}

// Specify the deployment properties for "type-safe" AWS Lambda.
//
// Unlike a typical AWS Lambda deployment where `func main()` serves as the
// entry point, this construct requires a function that returns a valid
// AWS Lambda handler of the form:
//
//	func M() func(context.Context, A) (B, error) {
//		/* AWS Lambda bootstrap code goes here */
//		return func(context.Context, A) (B, error) {
//			/* AWS Lambda handler goes here */
//		}
//	}
//
// The primary reason is that this construct automatically generates a `main` function
// file from the provided handler, ensuring consistent wiring and preserving type
// information throughout the deployment process.
//
// Use FunctionTyped as a constructor for FunctionTypedProps to eliminate the
// boilerplate
type FunctionTypedProps[A, B any] struct {
	*scud.FunctionGoProps
	Handler Lambda[A, B]
	AutoGen bool
}

func (f *FunctionTypedProps[A, B]) ForceAutoGen() *FunctionTypedProps[A, B] {
	f.AutoGen = true
	return f
}

// Constructor for NewFunctionTypedProps to support automatic inference of types from function
func NewFunctionTypedProps[A, B any](f Lambda[A, B], props *scud.FunctionGoProps) *FunctionTypedProps[A, B] {
	return &FunctionTypedProps[A, B]{
		FunctionGoProps: props,
		Handler:         f,
	}
}

//------------------------------------------------------------------------------

const agdir = "autogen"

// autogen generates a `main.go` file for the provided Lambda function.
// The file is created in the `autogen` directory relative to the source code module.
func autogen[A, B any](f Lambda[A, B], scModule string, force bool) string {
	fptr := reflect.ValueOf(f).Pointer()
	fobj := runtime.FuncForPC(fptr)
	if fobj == nil {
		panic(fmt.Errorf("failed to discover function metadata"))
	}

	name := fobj.Name()
	path := strings.TrimSuffix(name, filepath.Ext(name))
	base := filepath.Base(name)

	code := fmt.Sprintf(`// DO NOT EDIT !!!
// THE FILE IS AUTO GENERATED BY github.com/fogfish/typestep
// %s
package main

import (
  "github.com/aws/aws-lambda-go/lambda"
	"%s"
)

func main() { lambda.Start(%s()) }
`, time.Now(), path, base)

	gofile, _ := fobj.FileLine(fptr)
	codepath := filepath.Join(filepath.Dir(gofile), agdir, "main.go")

	if !force {
		if _, err := os.Stat(codepath); err == nil {
			// If the file already exists, we assume it has been generated before
			return strings.TrimPrefix(path, scModule)
		}
	}

	err := os.MkdirAll(filepath.Dir(codepath), 0766)
	if err != nil {
		panic(err)
	}
	err = os.WriteFile(codepath, []byte(code), 0766)
	if err != nil {
		panic(err)
	}

	return strings.TrimPrefix(path, scModule)
}
